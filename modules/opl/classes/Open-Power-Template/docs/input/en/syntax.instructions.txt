Title: Instructions

----

An instruction is any XML tag in one of the registered namespaces that:

* Is processed by OPT.
* It disappears during the compilation - we see there only the effects of their work.

Instructions are one of the main OPT syntax elements. They allow to create lists or display something conditionally. Let's take a closer look at them, using one of the instructions, `opt:section`. It is used to make lists. Below we can find a template that contains it:

~~~~
[xml]
<div id="menu">
	<h3>Menu</h3>
	<ol>
		<opt:section name="menu">
		<li><a parse:href="$menu.address">{$menu.title}</a></li>
		</opt:section>	
	</ol>	
</div>
~~~~

The code between `<opt:section>` and `</opt:section>` is treated as a look of the single list element. The section tells the parser, how to create a list from it, but it is not visible in the output code itself. There is only a result of its work, for example:

~~~~
[xml]
<div id="menu">
	<h3>Menu</h3>
	<ol>
		<li><a href="page1.php">Page 1</a></li>
		<li><a href="page2.php">Page 2</a></li>
		<li><a href="page3.php">Page 3</a></li>
		<li><a href="page4.php">Page 4</a></li>
	</ol>
</div>
~~~~

Some of the instructions have very sophisticated form and consist of many tags. The other ones can be used in certain places only.

Usually, the instructions are written in the declarative style. It means that you only tell, *what* you want to see, not *how* to implement it or how it should work. The goal is to eliminate the imperative programming with lots of loops and conditions from the templates, because it only makes the code ugly and hard to modify. The programming constructs are still available, but we recommend not to use it, and let the compiler work for you.

The instruction tags may take arguments as XML attributes. Each of them has strictly defined type that you have to follow. The following types are possible:

* Expression - any valid OPT expression that does not use the assignment operator.
* Expression with assignments - any valid OPT expression.
* String - a string value.
* Hard string - a string value.
* Option - *yes* or *no* values.
* Number
* Identifier - any valid identifier that begins with an underscore or a letter. Later, numbers are possible, too. Example: `foo123`. 

The first three types are expressions - the value you type is sent to the expression parser, so we can load their values from variables or functions. If the default type does not suit us, we can change it using another namespace:

~~~~
[xml]
<opt:instruction foo="here is a text by default"/>
~~~~

This sample instruction takes a string as the `foo` attribute. It is not a hard string, so we can load it from the variable. However, to do this, we must change the namespace to `parse` in order to mark that we want a full expression here:

~~~~
[xml]
<opt:instruction parse:foo="$load_me_from_variable"/>
~~~~

This namespace does not allow the assignment operator.

A similar relationship works also in the opposite direction. There are many instructions that take a full expression as an argument, but if we want to specify a string there, by default we have to deal with lots of quotes.

~~~~
[xml]
<opt:instruction2 foo="'I must have been enclosed in both double and single quotes. One of them come from XML, the second one - from OPT expressions'"/>
~~~~

We can avoid it by using `str` namespace:

~~~~
[xml]
<opt:instruction2 str:foo="Now the parser knows that we have a string here, so we don't need single quotes."/>
~~~~

The namespace does not have to be changed, if the string is a single word. As we remember from the chapter on expressions, OPT can recognize the string from the context. We can't change the namespace, if we want to concatenate a string with some variable. Otherwise, the variable call would be treated as a part of the text.

~~~~
[xml]
<opt:instruction2 bar="'add something here: '~$variable"/>
~~~~

The last four types cannot be changed. OPT needs them to compile the template properly and this is why their values cannot be loaded from variables or generated by expressions.

Notation
========

The instruction arguments are provided in this manual in the form of a table. If we find an asterisk in the "Name" field, it means that the instruction accepts any number of attributes of the specified type.