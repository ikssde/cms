<?php
/*
 *  OPEN POWER LIBS <http://www.invenzzia.org>
 *
 * This file is subject to the new BSD license that is bundled
 * with this package in the file LICENSE. It is also available through
 * WWW at this URL: <http://www.invenzzia.org/license/new-bsd>
 *
 * Copyright (c) Invenzzia Group <http://www.invenzzia.org>
 * and other contributors. See website for details.
 *
 */

/**
 * The lexer class for the expression parser. Note: this file
 * is automatically generated by PHP Parser Generator lexer
 * by Gregory Beaver. Do not modify it manually. Instead,
 * use the file /tools/lexer/expression_lexer.plex and parse
 * it with /tools/lexer/generateExpression.php.
 */
class Opt_Expression_Standard_Lexer
{
	/**
	 * The data field for the lexical analyzer.
	 */
	private $_data;
	/**
	 * The token counter for the lexical analyzer.
	 */
	private $_counter;
	/**
	 * The line counter for the lexical analyzer.
	 */
	private $_line;

	/**
	 * The recognized token number for parser.
	 * @var integer
	 */
	public $token;

	/**
	 * The recognized token value for parser.
	 * @var string
	 */
	public $value;

	/**
	 * Constructs the lexer object for parsing the specified
	 * expression.
	 *
	 * @param string $expression The expression to parse.
	 */
	public function __construct($expression)
	{
		$this->_data = $expression;
		$this->_line = 1;
		$this->_counter = 0;
	} // end __construct();


/*!lex2php
%input $this->_data
%counter $this->_counter
%token $this->token
%value $this->value
%line $this->_line
whitespace	= /\s+/
incdec	= /(\+\+|\-\-)/
add		= #\+#
minus	= /\-/
mul		= #\*#
div		= #\/#
mod		= #\%#
exp		= #\^#
not		= #\!#
eq		= #\=\=#
eqt		= #\=\=\=#
neq		= #\!\=#
neqt	= #\!\=#
dot		= /\./
concat	= /\~/
is_between		= /is\s+between/
is_not_between	= /is\s+not\s+between/
is_either		= /is\s+either/
is_neither		= /is\s+neither/
contains_both		= /contains\s+both/
contains_either		= /contains\s+either/
contains_neither	= /contains\s+neither/
is_in			= /is\s+in/
is_not_in		= /is\s+not\s+in/
is_both_in		= /is\s+both\s+in/
is_either_in	= /is\s+either\s+in/
is_neither_in	= /is\s+neither\s+in/
lbracket	= /\(/
rbracket	= /\)/
assign		= /\=/
dollar		= /\$/
at			= /\@/
dlsq_bracket	= /\</
drsq_bracket	= /\>/
lsq_bracket	= /\[/
rsq_bracket	= /\]/
object_op	= /\:\:/
comma		= /\,/
colon		= /\:/
identifier	= #[a-zA-Z\_][a-zA-Z0-9\_]*#
string		= /'[^'\\]*(?:\\.[^'\\]*)*'/
backticks	= /`[^`\\]*(?:\\.[^`\\]*)*`/
number		= #[0-9]+\.?[0-9]*#
hexadecimal	= /0[xX][0-9a-fA-F]+/
other		= /./
*/
/*!lex2php
%statename CODE
whitespace {
	$this->token = 'w';
}
incdec {
	if($this->value == '++')
	{
		$this->token = Opt_Expression_Standard_Parser::T_INCREMENT;
	}
	else
	{
		$this->token = Opt_Expression_Standard_Parser::T_DECREMENT;
	}
}
add {
	$this->token = Opt_Expression_Standard_Parser::T_ADD;
}
minus {
	$this->token = Opt_Expression_Standard_Parser::T_MINUS;
}
mul {
	$this->token = Opt_Expression_Standard_Parser::T_MUL;
}
div {
	$this->token = Opt_Expression_Standard_Parser::T_DIV;
}
mod {
	$this->token = Opt_Expression_Standard_Parser::T_MOD;
}
exp {
	$this->token = Opt_Expression_Standard_Parser::T_EXP;
}
not {
	$this->token = Opt_Expression_Standard_Parser::T_NOT;
}
eq {
	$this->token = Opt_Expression_Standard_Parser::T_EQUALS;
}
eqt {
	$this->token = Opt_Expression_Standard_Parser::T_EQUALS_T;
}
neq {
	$this->token = Opt_Expression_Standard_Parser::T_NEQUALS;
}
neqt {
	$this->token = Opt_Expression_Standard_Parser::T_NEQUALS_T;
}
concat {
	$this->token = Opt_Expression_Standard_Parser::T_CONCAT;
}
is_between {
	$this->token = Opt_Expression_Standard_Parser::T_IS_BETWEEN;
}
is_not_between {
	$this->token = Opt_Expression_Standard_Parser::T_IS_NOT_BETWEEN;
}
is_either {
	$this->token = Opt_Expression_Standard_Parser::T_IS_EITHER;
}
is_neither {
	$this->token = Opt_Expression_Standard_Parser::T_IS_NEITHER;
}
contains_both {
	$this->token = Opt_Expression_Standard_Parser::T_CONTAINS_BOTH;
}
contains_either {
	$this->token = Opt_Expression_Standard_Parser::T_CONTAINS_EITHER;
}
contains_neither {
	$this->token = Opt_Expression_Standard_Parser::T_CONTAINS_NEITHER;
}
is_in {
	$this->token = Opt_Expression_Standard_Parser::T_IS_IN;
}
is_not_in {
	$this->token = Opt_Expression_Standard_Parser::T_IS_NOT_IN;
}
is_both_in {
	$this->token = Opt_Expression_Standard_Parser::T_IS_BOTH_IN;
}
is_either_in {
	$this->token = Opt_Expression_Standard_Parser::T_IS_EITHER_IN;
}
is_neither_in {
	$this->token = Opt_Expression_Standard_Parser::T_IS_NEITHER_IN;
}
dollar {
	$this->token = Opt_Expression_Standard_Parser::T_DOLLAR;
}
at {
	$this->token = Opt_Expression_Standard_Parser::T_AT;
}
dot {
	$this->token = Opt_Expression_Standard_Parser::T_DOT;
}
assign {
	$this->token = Opt_Expression_Standard_Parser::T_ASSIGN;
}
lbracket {
	$this->token = Opt_Expression_Standard_Parser::T_L_BRACKET;
}
rbracket {
	$this->token = Opt_Expression_Standard_Parser::T_R_BRACKET;
}
dlsq_bracket {
	$this->token = Opt_Expression_Standard_Parser::T_DLSQ_BRACKET;
}
drsq_bracket {
	$this->token = Opt_Expression_Standard_Parser::T_DRSQ_BRACKET;
}
lsq_bracket {
	$this->token = Opt_Expression_Standard_Parser::T_LSQ_BRACKET;
}
rsq_bracket {
	$this->token = Opt_Expression_Standard_Parser::T_RSQ_BRACKET;
}
object_op {
	$this->token = Opt_Expression_Standard_Parser::T_OBJECT_OPERATOR;
}
comma {
	$this->token = Opt_Expression_Standard_Parser::T_COMMA;
}
colon {
	$this->token = Opt_Expression_Standard_Parser::T_COLON;
}
identifier {
	switch($this->value)
	{
		case 'add':
			$this->token = Opt_Expression_Standard_Parser::T_ADD;
			break;
		case 'sub':
			$this->token = Opt_Expression_Standard_Parser::T_SUB;
			break;
		case 'mul':
			$this->token = Opt_Expression_Standard_Parser::T_MUL;
			break;
		case 'div':
			$this->token = Opt_Expression_Standard_Parser::T_DIV;
			break;
		case 'mod':
			$this->token = Opt_Expression_Standard_Parser::T_MOD;
			break;
		case 'exp':
			$this->token = Opt_Expression_Standard_Parser::T_EXP;
			break;
		case 'and':
			$this->token = Opt_Expression_Standard_Parser::T_AND;
			break;
		case 'or':
			$this->token = Opt_Expression_Standard_Parser::T_OR;
			break;
		case 'nor':
			$this->token = Opt_Expression_Standard_Parser::T_NOR;
			break;
		case 'not':
			$this->token = Opt_Expression_Standard_Parser::T_NOT;
			break;
		case 'xor':
			$this->token = Opt_Expression_Standard_Parser::T_XOR;
			break;
		case 'eq':
			$this->token = Opt_Expression_Standard_Parser::T_EQUALS;
			break;
		case 'neq':
			$this->token = Opt_Expression_Standard_Parser::T_NEQUALS;
			break;
		case 'eqt':
			$this->token = Opt_Expression_Standard_Parser::T_EQUALS_T;
			break;
		case 'neqt':
			$this->token = Opt_Expression_Standard_Parser::T_NEQUALS_T;
			break;
		case 'gt':
			$this->token = Opt_Expression_Standard_Parser::T_GT;
			break;
		case 'lt':
			$this->token = Opt_Expression_Standard_Parser::T_LT;
			break;
		case 'gte':
			$this->token = Opt_Expression_Standard_Parser::T_GTE;
			break;
		case 'lte':
			$this->token = Opt_Expression_Standard_Parser::T_LTE;
			break;
		case 'contains':
			$this->token = Opt_Expression_Standard_Parser::T_CONTAINS;
			break;
		case 'exists':
			$this->token = Opt_Expression_Standard_Parser::T_EXISTS;
			break;
		case 'is':
			$this->token = Opt_Expression_Standard_Parser::T_ASSIGN;
			break;
		case 'true':
			$this->token = Opt_Expression_Standard_Parser::T_TRUE;
			break;
		case 'false':
			$this->token = Opt_Expression_Standard_Parser::T_FALSE;
			break;
		case 'null':
			$this->token = Opt_Expression_Standard_Parser::T_NULL;
			break;
		case 'new':
			$this->token = Opt_Expression_Standard_Parser::T_NEW;
			break;
		case 'clone':
			$this->token = Opt_Expression_Standard_Parser::T_CLONE;
			break;
		default:
			$this->token = Opt_Expression_Standard_Parser::T_IDENTIFIER;
	}
}
string {
	$this->token = Opt_Expression_Standard_Parser::T_STRING;
}
backticks {
	$this->token = Opt_Expression_Standard_Parser::T_BACKTICKS;
}
number {
	$this->token = Opt_Expression_Standard_Parser::T_NUMBER;
}
hexadecimal {
	$this->token = Opt_Expression_Standard_Parser::T_NUMBER;
}
*/

} // end Opt_Expression_Standard_Lexer;